<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--
  canvasplayer, 000000book edition
  Graffiti Markup Language (GML) playback using HTML5 canvas and Processing.js

  by Jamie Wilkinson... <http://jamiedubs.com> <http://github.com/jamiew>

	v1: initial implementation
  v2: multiple strokes, looping, iPhone translation, better stage positioning
	v3: time-driven playback, not just continuous

  TODO:
  * draw curves instead of simple lines
  * scale & center the drawing on the stage
-->
<html>
<head>
  <title>canvasplayer: GML Playback using Processing.js</title>
  <style type="text/css" media="screen">
    body { background: #fff; color: #222; font-family: sans-serif;margin: 0 auto; text-align: center; }
    body, canvas { width: 800px; }
    canvas { height: 580px; background-color: #000; border: 5px solid #222; }
    a, a:hover { color: #9f9f77; }
    h1 { letter-spacing: -1px; color: #000; margin-left: 20px; }
    h2 { font-family: "Arial", sans-serif; font-weight: normal; }
    #loading { position: absolute; margin: -5px 0 0 0px; }
    #tag_id { color: #999; text-transform: uppercase; font-size: 9pt; margin-top: -8px; }

    /* new navigation sidebar */
    #sidebar { position: absolute; margin-left: -170px; width: 150px; margin-top: 50px; overflow: hidden; font-size: 13pt; text-align: right; }
    #sidebar ul { list-style: none; line-height: 1.4em; }
    #sidebar hr { border: 0; border-bottom: 1px dotted #ccc; }
    #sidebar a.selected { text-decoration: none; color: #000; }
    #sidebar a.selected:after { content: "*"; color: #e33; font-weight: bold; }
  </style>
</head>
<body>

  <div id="loading">
    <img src="loading1.gif" alt="" title="" id="loading_animation" />
    <div id="tag_id">...</div>
  </div>

  <h1>canvasplayer: GML Playback using Processing.js</h1>
  <div id="sidebar">
    <div id="meta"></div>
    <h3>Load Tag:</h3>
    <ul>
      <li><a href="?latest" id="link-latest">Latest</a></li>
      <li><a href="?random" id="link-random">Random</a></li>
      <li><hr />
          <a href="?id=161" id="link-161">Katsu</a></li>
      <li><a href="?id=158" id="link-158">Jesus Saves</a></li>
      <li><a href="?id=1399" id="link-1399">Seen</a></li>
      <li><a href="?id=818" id="link-818">Hell</a></li>
      <li><a href="?id=148" id="link-148">hello world</a></li>
      <li><a href="?id=842" id="link-842">404</a></li>
      <li><hr />
          <small>more on <a href="http://000000book.com">000000book.com</a></small></li>
    </ul>
  </div>

  <canvas id="canvas"></canvas>
  <p>
    Code available at <a href="http://github.com/jamiew/canvasplayer">github.com/jamiew/canvasplayer</a>
    <p><strong>GML Webring:</strong> <a href="http://fffff.at/gml-week-graffiti-markup-language/">intro</a> / <a href="http://fffff.at/tag/gmlweek">recent projects</a> / <a href="http://fffff.at/gml">GML spec</a> / <a href="http://000000book.com">data (#000000book)</a</p>
  </p>


  <!-- Our Code! -->
  <script id="sketch" type="text/javascript">

  // big TODO: use the time data instead of just doing continuous time playback
  void setup(){
    // setup our canvas
    size(800, 580);
    fps = 60;
    frameRate(fps);
    background(0);
    // smooth();

    downsampling_enabled = false;
    interpolate_points = false;

    // read orientation/scaling headers from the GML
    // DustTag's GML does not specify orientation/scaling, so we're explicitly fixing known iPhone apps
    var app_name = gml.tag.header && gml.tag.header.client && gml.tag.header.client.name;
    if(app_name == 'Graffiti Analysis 2.0: DustTag' || app_name == 'DustTag: Graffiti Analysis 2.0' || app_name == 'Fat Tag - Katsu Edition'){
      rotation = 80;
      translation = [0, 800]; // still gets cropped; should scale down all values
      console.log('iPhone app detected, rotating ...');
    } else {
      rotation = 0;
      translation = [0, 0];
      // console.log("Unknown appplication source: "+app_name);
      // console.log(gml.tag.header);
    }
    console.log("rotation="+rotation+" translation="+translation);

    // read data from the GML (GSON), loaded via #000000book JSONp callback
    // the <script> tag is finicky if not at the bottom of the page, after the Processing.js sketch
    pts = [];
    // edges = {'top':0, 'right':0, 'bottom':0, 'left':0};
    edges = []
    edges['top'] = 0;
    edges['right'] = 0;
    edges['bottom'] = 0;
    edges['left'] = 0;
    strokes = (gml.tag.drawing.stroke instanceof Array ? gml.tag.drawing.stroke : [gml.tag.drawing.stroke]);
    for(i in strokes){
      console.log("Reading stroke #"+i+" ...");
      pts = pts.concat(strokes[i].pt);
      pts.push(undefined); //blank obj to indicate new stroke
    }
    end_time = pts[pts.length-2].time*1000; // -1 is our end-of-stroke undefined
    console.log(edges);

    // Set initial drawing vector...
    pt = pts[0];
    nxt = pts[1];
    prev = undefined;
    multiplier = 1; // don't use
    queued_at = pt.time*1000*multiplier;

    drawnPoints = 0;
    interpolatedPoints = 0;

    console.log(pts.length+" points");
    console.log("time="+end_time+"ms");

    // ghetto: downsample GML that is too complex to draw in realtime
    // I think we should be pre-computing all of our drawable frames
    // (or at least paths) which would avoid this entirely...
    threshold = 5;
    density = 100/(end_time/pts.length);
    console.log("point density = "+density);
    if(density > threshold && downsampling_enabled){
      // totally arbitrary based on debugging some drawings
      if(density > threshold + 4){
        amount = 4;
      } else if(density > threshold + 2){
        amount = 3;
      } else {
        amount = 2;
      }
      console.log("downsampling GML, amount="+amount);

      newpts = [];
      for(int i = 0; i < pts.length; i++){
        // skip a great deal of points, but
        // always include undefined (stroke separators)
        if(i % amount == 0 || pts[i] == undefined){
          newpts.push(pts[i]);
        }
      }
      oldpts = pts;
      pts = newpts;
    }

    cursor_x = 0;
    cursor_y = 0;
    cursor_time = 0;

  }

  void setPoints(){
    prev = pts[drawnPoints-1];
    pt = pts[drawnPoints];
    drawnPoints++;
    if(pts[drawnPoints]){
      nxt = pts[drawnPoints];
      queued_at = nxt.time*1000*multiplier;
    }
  }

  void debugFrame(){
    if(pt){
      console.log("frameCount="+frameCount+" x="+cursor_x+" y="+cursor_y+" drawnPoints="+drawnPoints+" diff="+diff);
    }
    else{
      console.log("frameCount="+frameCount+"... no point?!?");
    }
  }

  void draw(){

    // debug our frame
    diff = millis()-queued_at;
    if(frameCount % 50 == 0){
      debugFrame();
    }

    // skip ahead if we're laaaaaaggging
    if(diff > 50 && downsampling_enabled == false){
      setPoints();
    }

    // debug abort
    // if(millis() > 1000){ exit(); }

    // update point if we've reached the next one
    if(millis() > queued_at){
      setPoints();
      // console.log("millis="+millis()+" drawnPoints="+drawnPoints+" pt.time="+pt.time*1000+" queued_at="+queued_at+" diff="+diff);
      cursor_x = parseFloat(pt.x);
      cursor_y = parseFloat(pt.y);

      strokeWeight(8);
      stroke(255);
    }
    else if(interpolate_points){
      // otherwise move the point along the specified amount...
      // interpolate the rest of the drawing points...
      // distance = nxt - pt
      // ms = nxt.time - pt.time
      hmm = (nxt.time*1000) - (pt.time*1000);
      ms = nxt.time*1000 - millis();
      if(nxt == undefined){ return; }
      dimx = (cursor_x - nxt.x);
      dimy = (cursor_y - nxt.y);
      // hyp = sqrt(pow(dimx,2),pow(dimy,2));

      if(ms != 0){
        cursor_x += parseFloat(dimx/ms*2);
        cursor_y += parseFloat(dimy/ms*2);
        cursor_time += ms;
        // console.log("interpolating... millis="+millis()+" ms="+ms+" cursor=("+cursor_x+","+cursor_y+") SHIFT=("+dimx+","+dimy+")");
        interpolatedPoints++;
      }
      strokeWeight(8);
      stroke(210);
    }
    else {
      // non-draws...?
    }

    // drawing rules
    if(millis() > end_time){
      console.log("draw time expired, "+drawnPoints+" points drawn of "+pts.length+ "... "+Math.round(drawnPoints/pts.length*100)+"%");
      console.log(interpolatedPoints+" interpolated points");
      exit();
    }
    if(nxt == undefined){ console.log("no next point, drawing complete."); exit(); }
    //if(frameCount % pts.length == 0){ background(0); } // clear on restart (first frame)
    if(pt == undefined || pt == []){ return; } // if missing current pt, we are skipping
    if(prev == undefined || prev == []){ prev = pt; } // if missing the prev, we're at the beginning of a new stroke

    // draw
    dimx = (prev.x - cursor_x)*width;
    dimy = (prev.y - cursor_y)*height;
    hyp = 1/(sqrt(pow(dimx,2),pow(dimy,2)) + 1);

    // acceleration adjusts stroke width
    //strokeMultiplier = 250;
    //strokeWeight(hyp * strokeMultiplier);

    // set stage
    offset = 0; // TODO scaling to canvas size correctly
    x1 = parseFloat(prev.x*width) + offset;
    y1 = parseFloat(prev.y*height) + offset;
    x2 = parseFloat(cursor_x*width) + offset;
    y2 = parseFloat(cursor_y*height) + offset;

    // console.log("1=("+x1+","+y1+") 2=("+x2+","+y2+")");
    line(x1, y1, x2, y2);
    // bezier(x1,y1, x1+dimx,y1+dimy, x2+dimx,y2+dimy, x2,y2);
    
    // transform display space if specified
    // FIXME exactly what order should we be doing this?
    translate(translation[0], translation[1]);
    rotate(rotation);    
  }
  </script>
  <script src="processing.min.js" type="text/javascript" charset="utf-8"></script>

  <!-- the GML data, served from #000000book and initialized in a callback -->

  <script type="text/javascript" charset="utf-8">
    // mock console.log() if no Firebug
    if(!console || !console.log) {
      var console = new Array();
      console.log = function () {}
    }

    // callback method
    function load_gml(data){
      gml = data.gml;
      document.getElementById("loading").innerHTML = '';
      var canvas = document.getElementById("canvas");
      var sketch = document.getElementById("sketch").text;
      var p = Processing(canvas, sketch, gml);
    };
  </script>

  <!-- load our GML data! using JSON+callback from 000000book.com, the GML database -->
  <!-- <script src="http://000000book.com/data/2365.json?callback=load_gml" type="text/javascript" charset="utf-8"></script>   -->

  <!-- a more complex example to handle our new URL query variable -> tag loading navigation sidebar -->
  <script type="text/javascript" charset="utf-8">
    // ?id=154
    // ?random
    // ?latest
    var tag_id = 161; // default to Katsu
    var matches = document.location.href.match(/id=(\d+)/);
    console.log(matches);
    if(matches && matches[1]){ tag_id = matches[1]; }
    else if(/latest/.test(document.location.href)){ tag_id = 'latest'; }
    else if(/random/.test(document.location.href)){ tag_id = 'random'; }

    // update our "UI"
    document.getElementById("tag_id").innerHTML = tag_id;
    if(document.getElementById("link-"+tag_id)){ document.getElementById("link-"+tag_id).className = 'selected'; }

    // append the appropriate <script> tag
    var s=document.createElement('script');
    s.setAttribute('src','http://000000book.com/data/'+tag_id+'.json?callback=load_gml');
    document.getElementsByTagName('body')[0].appendChild(s);
  </script>

<!-- stats tracking -->
<!--<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-96220-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ga);
  })();
</script>-->

</body>
</html>